
import "io.vo";
import "tokens.vo";
import "ast.vo";
import "lexer.vo";
import "mem.vo";

struct ParserState {
	buff:	 *i8;
	line:	  size_t;
	column:   size_t;
};

export struct Parser {
	lexer:	   lexer.Lexer;
	current:   tokens.Token;
	context:   u8;

	func peek(self: *Parser) tokens.Token {
		return self.current;
	};
	func eat(self: *Parser) {
		self.current = self.lexer.next();
	};
	func eatRaw(self: *Parser) {
		self.current = self.lexer.nextRaw();
	};
	func clean(self: *Parser) {
		if self.peek().pType == tokens.PTokenType.SPACE {
			self.eatRaw();
		}
	};
	func error(self: *Parser, msg: *i8) {
		$printf("Error %zu:%zu ", self.lexer.line, self.lexer.column);
		io.println(msg);
		$exit(1);
	};
	func state(self: *Parser) ParserState {
		return (ParserState){line: self.current.line, column: self.current.column, buff: self.current.buff};
	};
	func stmtNode(self: *Parser, state: *ParserState) *ast.Stmt {
		return new ast.Stmt{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func exprNode(self: *Parser, state: *ParserState) *ast.Expr {
		return new ast.Expr{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func typeNode(self: *Parser, state: *ParserState) *ast.Type {
		return new ast.Type{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func patternNode(self: *Parser, state: *ParserState) *ast.Pattern {
		return new ast.Pattern{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func expectPri(self: *Parser, t: tokens.PTokenType) tokens.Token {
		tok := self.peek();
		if tok.pType == t {
			return tok;
		} else {
			$printf("%u\n", t);
			tok.print();
			self.error("expected {t}, got {tok.pType}.");
		}
		return tok;
	};
	func expectSec(self: *Parser, t: tokens.STokenType) tokens.Token {
		tok := self.peek();
		if tok.sType == t {
			return tok;
		} else {
			tok.print();
			self.error("expected {t}, got {tok.pType}.");
		}
		return tok;
	};
	func assert(self: *Parser, cond: bool, msg: *i8) {
		if cond {
			return;
		} else {
			self.error(msg);
		}
	};
	func identVec(self: *Parser) vec ast.IdentExpr {
		idents := (vec ast.IdentExpr){};
		idents.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
		self.eat();

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			idents.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
			self.eat();
		}
		return idents;
	};
	func typeVec(self: *Parser) vec *ast.Type {
		types := (vec *ast.Type){};
		types.push(self.type());

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			types.push(self.type());
		}
		return types;
	};
	func decTypeVec(self: *Parser) vec *ast.Type {
		types := (vec *ast.Type){};
		types.push(self.decType());

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			types.push(self.decType());
		}
		return types;
	};
	func exprVec(self: *Parser) vec *ast.Expr {
		exprs := (vec *ast.Expr){};
		exprs.push(self.expr());

		for tok := self.peek(); tok.sType == tokens.STokenType.COMMA; tok = self.peek() {
			self.eat();
			exprs.push(self.expr());
		}
		return exprs;
	};
	func globalStmt(self: *Parser) *ast.Stmt {
		s := self.globalStmtRaw();

		self.expectPri(tokens.PTokenType.SEMICOLON);
		self.eat();
		
		return s;
	};
	func globalStmtRaw(self: *Parser) *ast.Stmt {
		tok := self.peek();
		
		switch tok.pType {
		case tokens.PTokenType.IDENT:
			return self.dec();
		case tokens.PTokenType.SEMICOLON:
			return self.nullStmt();
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.IMPORT:
			return self.imprt();
		case tokens.STokenType.STRUCT:
			return self.structTypedef();
		case tokens.STokenType.ENUM:
			return self.enumTypedef();
		case tokens.STokenType.TUPLE:
			return self.tupleTypedef();
		case tokens.STokenType.UNION:
			return self.unionTypedef();
		case tokens.STokenType.TYPEDEF:
			return self.tdef();
		/*
		case tokens.STokenType.EXPORT:
			return self.exprt();
		*/
		case tokens.STokenType.FUNC:
			return self.funcDec();
		default:
			return null;
		}
	};
	func localStmt(self: *Parser) *ast.Stmt {
		s := self.localStmtRaw();
		
		if self.peek().pType == tokens.PTokenType.SEMICOLON {
			self.eat();
		}
		return s;
	};
	func localStmtRaw(self: *Parser) *ast.Stmt {
		tok := self.peek();
		
		switch tok.pType {
		case tokens.PTokenType.LCBRACE:
			return self.block();
		case tokens.PTokenType.SEMICOLON:
			return self.nullStmt();
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.RETURN:
			return self.rturn();
		case tokens.STokenType.FUNC:
			return self.funcDec();
		case tokens.STokenType.IF:
			return self.ifElse();
		case tokens.STokenType.SWITCH:
			return self.swtch();
		case tokens.STokenType.FOR:
			return self.loop();
		case tokens.STokenType.DELETE:
			return self.del();
		case tokens.STokenType.BREAK:
			goto brak;
		case tokens.STokenType.CONTINUE:
			goto continuee;
		case tokens.STokenType.STRUCT:
			return self.structTypedef();
		case tokens.STokenType.ENUM:
			return self.enumTypedef();
		case tokens.STokenType.TUPLE:
			return self.tupleTypedef();
		case tokens.STokenType.UNION:
			return self.unionTypedef();
		case tokens.STokenType.TYPEDEF:
			return self.tdef();
		case tokens.STokenType.LABEL:
			return self.labl();
		case tokens.STokenType.GOTO:
			return self.gotoh();
		case tokens.STokenType.CASE:
			goto casee;
		case tokens.STokenType.DEFAULT:
			goto defalt;
		default:
			return self.decAssignExpr();
		}
	
	label brak:
		if self.context & 0x80 != 1 && self.context & 0x40 != 1 {
			self.error("bruh break not allowed outside loops and switch statements.");
		}
		return self.brak();
	label continuee:
		if self.context & 0x40 == 0 {
			self.error("bruh break not allowed outside loops.");
		}
		return self.continuee();
	label casee:
		if self.context & 0x80 == 0 {
			self.error("bruh case not allowed outside switch statements");
		}
		return self.casee();
	label defalt:
		if self.context & 0x80 == 0 {
			self.error("bruh default not allowed outside switch statements");
		}
		return self.defalt();
	};
	func basicStmt(self: *Parser) *ast.Stmt {
		tok := self.peek();
		
		switch tok.pType {
		case tokens.PTokenType.IDENT:
			return self.decAssignExpr();
		case tokens.PTokenType.SEMICOLON:
			return self.nullStmt();
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.LABEL:
			return self.labl();
		case tokens.STokenType.CASE:
			goto casee;
		case tokens.STokenType.DEFAULT:
			goto defalt;
		default:
			return self.exprStmt();
		}

	label casee:
		if self.context & 0x80 == 0 {
			self.error("bruh case not allowed outside switch statements");
		}
		return self.casee();
	label defalt:
		if self.context & 0x80 == 0 {
			self.error("bruh default not allowed outside switch statements");
		}
		return self.defalt();
	};
	func nullStmt(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.NULL;
		
		return stmt;
	};
	func brak(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.BREAK;
		
		return stmt;
	};
	func continuee(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.CONTINUE;
		
		return stmt;
	};
	func defalt(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.DEFAULT;
		
		return stmt;
	};
	func exprStmt(self: *Parser) *ast.Stmt {
		state := self.state();
		expr := self.expr();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.EXPR;
		stmt.data.expr = (ast.ExprStmt){expr};
		
		return stmt;
	};
	func rturn(self: *Parser) *ast.Stmt {
		state := self.state();
		rturn := self.rturnRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.RETURN;
		stmt.data.rturn = rturn;
		return stmt;
	};
	func rturnRaw(self: *Parser) ast.Return {
		self.eat();
		return (ast.Return){val: self.expr()};
	};
	func casee(self: *Parser) *ast.Stmt {
		state := self.state();
		casee := self.caseeRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.CASE;
		stmt.data.casee = casee;
		return stmt;
	};
	func caseeRaw(self: *Parser) ast.Case {
		self.eat();
		c := (ast.Case){val: self.expr()};
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		return c;
	};
	func block(self: *Parser) *ast.Stmt {
		state := self.state();
		block := self.blockRaw();
		stmt := self.stmtNode(&state);
		
		stmt.type = ast.StmtType.BLOCK;
		stmt.data.block = block;
		
		return stmt;
	};
	func blockRaw(self: *Parser) ast.Block {
		self.eat();
		block := (ast.Block){stmts: (vec ast.Stmt){}};
		
		for self.peek().pType != tokens.PTokenType.RCBRACE {
			block.stmts.push(self.localStmt());
		}
		self.eat();
		return block;
	};
	func imprt(self: *Parser) *ast.Stmt {
		state := self.state();
		imprt := self.imprtRaw();
		stmt := self.stmtNode(&state);

		stmt.type = ast.StmtType.IMPORT;
		stmt.data.imprt = imprt;
		
		return stmt;
	};
	func imprtRaw(self: *Parser) ast.Import {
		imprt := (ast.Import){};

		self.eat();
		imprt.path = new ast.BasicLit{self.expectPri(tokens.PTokenType.STR_LIT)};
		self.eat();

		if self.peek().pType == tokens.STokenType.AS {
			self.eat();
			imprt.name = new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
			self.eat();
		} else {
			/*
			imprt.name = cast(*ast.IdentExpr)(new tokens.Token{

			});
			*/
		}
		return imprt;
	};
	func decAssignExpr(self: *Parser) *ast.Stmt {
		state := self.state();
		exprs := self.exprVec();

		if tok := self.peek(); tok.sType == tokens.STokenType.COLON {
			return self.decBody(&state, exprs);
		} else if tok.pType == tokens.PTokenType.ASSIGN_OP {
			return self.assignBody(&state, exprs);
		} else if exprs.length == 1 {
			stmt := self.stmtNode(&state);
			stmt.type = ast.StmtType.EXPR;
			stmt.data.expr = (ast.ExprStmt){expr: exprs[0]};
			exprs.free();
			return stmt;
		}
		
		self.error("expected assignment operator, got {s}.");
		return null;
	};
	func dec(self: *Parser) *ast.Stmt {
		state := self.state();
		idents := self.exprVec();

		return self.decBody(&state, idents);
	};
	func decBody(self: *Parser, statePtr: *ParserState, e: *void) *ast.Stmt {
		exprs := cast(vec *ast.Expr)e;
		
		for i := 0; i < exprs.length; ++i {
			self.assert(exprs[i].type == ast.ExprType.IDENT, "bruh gib identifiers.");
		}
		self.eat();

		dec := (ast.Declaration){idents: exprs};
		
		if self.peek().sType != tokens.STokenType.EQ {
			dec.types = self.decTypeVec();
		} else {
			goto eq;
			dec.types = null;
		}

		if self.peek().sType == tokens.STokenType.EQ {
		label eq:
			self.eat();
			dec.values = self.exprVec();
		} else {
			dec.values = null;
		}

		stmt := self.stmtNode(statePtr);
		stmt.type = ast.StmtType.DEC;
		stmt.data.dec = dec;
		return stmt;
	};
	func decNoVal(self: *Parser) *ast.Stmt {
		state := self.state();
		dec := self.decNoValRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.DEC;
		stmt.data.dec = dec;
		return stmt;
	};
	func decNoValRaw(self: *Parser) ast.Declaration {
		dec := (ast.Declaration){idents: self.exprVec()};

		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		dec.types = self.decTypeVec();
		dec.values = null;

		return dec;
	};
	func assignBody(self: *Parser, statePtr: *ParserState, e: *void) *ast.Stmt {
		exprs := cast(vec *ast.Expr)e;
		assign := (ast.Assignment){};

		for i := 0; i < exprs.length; ++i {
			expr := exprs[i];
			self.assert((
				expr.type == ast.ExprType.IDENT   ||
				expr.type == ast.ExprType.MEMBER  ||
				expr.type == ast.ExprType.ELEMENT ||
				(expr.type == ast.ExprType.UNARY && (cast(*ast.Operator)(expr.data.unary.op)).tok.sType == tokens.STokenType.MUL)
			), "bruh gib identifiers.");
		}

		assign.vars = exprs;
		assign.op = new (ast.Operator){self.peek()};

		self.eat();
		assign.vals = self.exprVec();

		stmt := self.stmtNode(statePtr);
		stmt.type = ast.StmtType.ASSIGN;
		stmt.data.assign = assign;
		return stmt;
	};
	func funcDec(self: *Parser) *ast.Stmt {
		state := self.state();
		dec := self.funcDecRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.FUNC;
		stmt.data.funcDec = dec;

		return stmt;
	};
	func funcDecRaw(self: *Parser) ast.FuncDec {
		self.eat();

		dec := (ast.FuncDec){};
		dec.type.args.names = (vec ast.IdentExpr){};
		dec.type.args.types = (vec *ast.Type){};

		tok := self.peek();

		if tok.pType == tokens.PTokenType.IDENT {
			dec.type.type = ast.FuncTypeEnum.ORD;
			dec.name = new ast.IdentExpr{tok};
			goto funcBody;
		}

		switch tok.sType {
		case tokens.STokenType.WORK:
			dec.type.type = ast.FuncTypeEnum.WORK;
			self.eat();
			break;
		case tokens.STokenType.ASYNC:
			dec.type.type = ast.FuncTypeEnum.ASYNC;
			self.eat();
			break;
		case tokens.STokenType.NATIVE:
			dec.type.type = ast.FuncTypeEnum.NATIVE;
			self.eat();
			break;
		default:
			dec.type.type = ast.FuncTypeEnum.ORD;
			break;
		}
		dec.name = new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		
	label funcBody:
		self.eat();
		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();

		if self.peek().pType == tokens.PTokenType.RPAREN {
			goto next;
		}
		goto body;

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();

		label body:	
			dec.type.args.names.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
			self.eat();
			self.expectSec(tokens.STokenType.COLON);
			self.eat();
			dec.type.args.types.push(self.type());
		}
		self.expectPri(tokens.PTokenType.RPAREN);
	
	label next:
		self.eat();

		if self.peek().pType == tokens.PTokenType.LCBRACE {
			dec.type.returnType = null;
		} else {
			dec.type.returnType = self.type();
			self.expectPri(tokens.PTokenType.LCBRACE);
		}

		dec.body = self.blockRaw();
		return dec;
	};
	func labl(self: *Parser) *ast.Stmt {
		state := self.state();
		labl := self.lablRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.LABEL;
		stmt.data.labl = labl;
		return stmt;
	};
	func lablRaw(self: *Parser) ast.Label {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		return (ast.Label){name};
	};
	func gotoh(self: *Parser) *ast.Stmt {
		state := self.state();
		gotoh := self.gotohRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.GOTO;
		stmt.data.gotoh = gotoh;
		return stmt;
	};
	func gotohRaw(self: *Parser) ast.Goto {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		return (ast.Goto){name};
	};
	func ifElse(self: *Parser) *ast.Stmt {
		state := self.state();
		ifElse := self.ifElseRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.IF_ELSE;
		stmt.data.ifElse = ifElse;
		return stmt;
	};
	func ifElseRaw(self: *Parser) ast.IfElse {
		ifElse := (ast.IfElse){
			conds:	 (vec *ast.Expr){}, 
			initStmts: (vec *ast.Stmt){},
			blocks:	(vec ast.Block){}
		};
		
		label body:

		self.eat();
		stmt := self.basicStmt();
		
		if self.peek().pType == tokens.PTokenType.LCBRACE {
			ifElse.initStmts.push(null);

			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression not statement");
			ifElse.conds.push(stmt.data.expr.expr);

			delete stmt;
		} else if self.peek().pType == tokens.PTokenType.SEMICOLON {
			self.eat();
			ifElse.initStmts.push(stmt);

			ifElse.conds.push(self.expr());
			self.expectPri(tokens.PTokenType.LCBRACE);
		}

		ifElse.blocks.push(self.blockRaw());
		
		if self.peek().sType != tokens.STokenType.ELSE {
			ifElse.elseBlock = (ast.Block){stmts: null};
			return ifElse;
		}
		self.eat();

		if self.peek().sType == tokens.STokenType.IF {
			goto body;
		}
		
		self.expectPri(tokens.PTokenType.LCBRACE);
		ifElse.elseBlock = self.blockRaw();
		return ifElse;
	};
	func swtch(self: *Parser) *ast.Stmt {
		state := self.state();
		swtch := self.swtchRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.SWITCH;
		stmt.data.swtch = swtch;
		
		return stmt;
	};
	func swtchRaw(self: *Parser) ast.Switch {
		self.eat();
		swtch := (ast.Switch){};
		
		if stmt := self.basicStmt(); self.peek().pType == tokens.PTokenType.LCBRACE {
			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression, not type");
			swtch.initStmt = null;
			swtch.expr = stmt.data.expr.expr;
			delete stmt;
		} else {
			swtch.initStmt = stmt;
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
			swtch.expr = self.expr();
			self.expectPri(tokens.PTokenType.LCBRACE);
		}

		self.context = self.context | 0x80;
		swtch.block = self.blockRaw();
		self.context = self.context & ~0x80;

		return swtch;
	};
	func loop(self: *Parser) *ast.Stmt {
		state := self.state();
		loop := self.loopRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.LOOP;
		stmt.data.loop = loop;
		
		return stmt;
	};
	func loopRaw(self: *Parser) ast.Loop {
		self.eat();
		loop := (ast.Loop){};

		if p := self.peek().pType; p == tokens.PTokenType.LCBRACE {
			loop.initStmt = null;
			loop.cond = null;
			loop.loopStmt = null;
			goto end;
		} else if p == tokens.PTokenType.SEMICOLON {
			loop.initStmt = null;
			goto cond;
		}

		stmt := self.basicStmt();
		
		if self.peek().pType == tokens.PTokenType.SEMICOLON {
			loop.initStmt = stmt;
		} else if stmt.type == ast.StmtType.EXPR {
			loop.initStmt = null;
			loop.cond = stmt.data.expr.expr;
			delete stmt;
			goto afterCond;
		} else {
			self.error("buh gib expression");
		}

	label cond:
		self.eat();

		if p := self.peek().pType; p == tokens.PTokenType.LCBRACE {
			loop.cond = null;
			loop.loopStmt = null;
			goto end;
		} else if p != tokens.PTokenType.SEMICOLON {
			loop.cond = self.expr();
		} else {
			loop.cond = null;
			goto final;
		}

	label afterCond:
		if p := self.peek().pType; p == tokens.PTokenType.LCBRACE {
			loop.loopStmt = null;
			goto end;
		} else if p != tokens.PTokenType.SEMICOLON {
			self.error("buh gib semicolon");	
		}

	label final:
		self.eat();

		if self.peek().pType == tokens.PTokenType.LCBRACE {
			loop.loopStmt = null;
		} else {
			loop.loopStmt = self.basicStmt();
		}

	label end:
		self.context = self.context | 0x40;
		loop.block = self.blockRaw();
		self.context = self.context & ~0x40;

		return loop;
	};
	func del(self: *Parser) *ast.Stmt {
		state := self.state();
		del := self.delRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.DELETE;
		stmt.data.del = del;
		
		return stmt;
	};
	func delRaw(self: *Parser) ast.Delete {
		self.eat();
		return (ast.Delete){exprs: self.exprVec()};
	};
	func tdef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.tdefRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;
		
		return stmt;
	};
	func tdefRaw(self: *Parser) ast.Typedef {
		self.eat();
		tdef := (ast.Typedef){};

		tdef.name = new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();

		tdef.type = self.type();
		return tdef;
	};
	func expr(self: *Parser) *ast.Expr {
		return self.expr0();
	};
	func expr0(self: *Parser) *ast.Expr { // ?:
		state := self.state();
		cond := self.expr1();

		if tok := self.peek(); tok.sType != tokens.STokenType.QMARK {
			return cond;
		}
		self.eat();
		left := self.expr0();

		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		right := self.expr1();
		ternary := (ast.TernaryExpr){left: left, cond: cond, right: right};
		
		expr := self.exprNode(&state);
		expr.type = ast.ExprType.TERNARY;
		expr.data.ternary = ternary;
		return expr;
	};
	func expr1(self: *Parser) *ast.Expr { // &&, ||
		state := self.state();
		left := self.expr2();

		for tok := self.peek(); tok.pType == tokens.PTokenType.LOGIC_OP; tok = self.peek() {
			self.eat();
			right := self.expr2();
			
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr2(self: *Parser) *ast.Expr { // &, |, ^
		state := self.state();
		left := self.expr3();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.OR  || 
			tok.sType == tokens.STokenType.AND ||
			tok.sType == tokens.STokenType.XOR;
			tok = self.peek() {
		
			self.eat();
			right := self.expr3();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr3(self: *Parser) *ast.Expr { // &&, ||
		state := self.state();
		left := self.expr4();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.EQEQ  || 
			tok.sType == tokens.STokenType.NOTEQ;
			tok = self.peek() {
		
			self.eat();
			right := self.expr4();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr4(self: *Parser) *ast.Expr { // >, <, >=, <=
		state := self.state();
		left := self.expr5();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.GTEQ || 
			tok.sType == tokens.STokenType.LTEQ ||
			tok.sType == tokens.STokenType.GT   || 
			tok.sType == tokens.STokenType.LT;
			tok = self.peek() {
		
			self.eat();
			right := self.expr5();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr5(self: *Parser) *ast.Expr { // >>, <<
		state := self.state();
		left := self.expr6();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.LSHIFT || 
			tok.sType == tokens.STokenType.RSHIFT;
			tok = self.peek() {
		
			self.eat();
			right := self.expr6();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr6(self: *Parser) *ast.Expr { // +, -
		state := self.state();
		left := self.expr7();
		
		for tok := self.peek(); 
			tok.sType == tokens.STokenType.ADD || 
			tok.sType == tokens.STokenType.SUB;
			tok = self.peek() {
			
			self.eat();
			right := self.expr7();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr7(self: *Parser) *ast.Expr { // /, *, %
		state := self.state();
		left := self.expr8();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.DIV || 
			tok.sType == tokens.STokenType.MUL || 
			tok.sType == tokens.STokenType.MOD;
			tok = self.peek() {
		
			self.eat();
			right := self.expr8();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr8(self: *Parser) *ast.Expr { // unuary *, &, +, -, ++, --, !, ~, new, cast, sizeof
		tok := self.peek();

		if tok.sType == tokens.STokenType.MUL	 || 
			tok.sType == tokens.STokenType.AND	|| 
			tok.sType == tokens.STokenType.ADD	|| 
			tok.sType == tokens.STokenType.SUB	|| 
			tok.sType == tokens.STokenType.LNOT   || 
			tok.sType == tokens.STokenType.BNOT   || 
			tok.sType == tokens.STokenType.ADDADD || 
			tok.sType == tokens.STokenType.SUBSUB {
			
			state := self.state();
			self.eat();
			e := self.expr8();

			expr := self.exprNode(&state);
			expr.type = ast.ExprType.UNARY;
			expr.data.unary = (ast.UnaryExpr){expr: e, op: new ast.Operator{tok}};
			return expr;
		} else if tok.sType == tokens.STokenType.CAST {
			return self.castExpr();
		} else if tok.sType == tokens.STokenType.AWAIT {
			return self.awaitExpr();
		} else if tok.sType == tokens.STokenType.SIZEOF {
			return self.sizeExpr();
		} else if tok.sType == tokens.STokenType.NEW {
			return self.newExpr();
		}
		return self.expr9();
	};
	func expr9(self: *Parser) *ast.Expr { // posifix ++, --, function call, member, element
		state := self.state();
		e := self.expr10();

	label loop:
		if tok := self.peek(); tok.pType == tokens.PTokenType.LPAREN {
			e = self.callExpr(e, &state);
		} else if tok.sType == tokens.STokenType.DOT {
			self.eat();
			prop := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
			self.eat();
			x := self.exprNode(&state);
			x.type = ast.ExprType.MEMBER;
			x.data.member = (ast.MemberExpr){base: e, prop: prop};
			e = x;
		} else if tok.pType == tokens.PTokenType.LBRACE {
			self.eat();
			index := self.expr();
			self.expectPri(tokens.PTokenType.RBRACE);
			self.eat();
			x := self.exprNode(&state);
			x.type = ast.ExprType.ELEMENT;
			x.data.element = (ast.ElementExpr){base: e, index: index};
			e = x;
		} else if tok.sType == tokens.STokenType.ADDADD || tok.sType == tokens.STokenType.SUBSUB {
			self.eat();
			x := self.exprNode(&state);
			x.type = ast.ExprType.PUNARY;
			x.data.unary = (ast.UnaryExpr){expr: e, op: new ast.Operator{tok}};
			e = x;
		} else {
			return e;
		}
		goto loop;
	};
	func expr10(self: *Parser) *ast.Expr { // parenthesis, compound literal, array initializer
		state := self.state();
		e: *ast.Type;

		switch self.peek().pType {
		case tokens.PTokenType.LPAREN:
			e = self.type();
			break;
		case tokens.PTokenType.LCBRACE:
			return self.arrayInitializer();
		default:
			return self.expr11();
		}

		if self.peek().pType != tokens.PTokenType.LCBRACE {
			self.clean();
			self.assert(e.type == ast.TypeType.BASIC, "gib expression, not type.");
			
			expr := cast(*ast.Expr)e.data.basic.expr;
			delete e;
			return expr;
		}

		c := (ast.CompLit){type: e};
		self.compLitData(&c);

		ee := self.exprNode(&state);
		ee.type = ast.ExprType.COMPLIT;
		ee.data.compLit = c;

		return ee;
	};
	func expr11(self: *Parser) *ast.Expr {
		state := self.state();
		tok := self.peek();
		expr: *ast.Expr;
		
		switch tok.pType {
		case tokens.PTokenType.IDENT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.IDENT;
			goto end;
		case tokens.PTokenType.STR_LIT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.STR_LIT;
			goto end;
		case tokens.PTokenType.CHAR_LIT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.CHR_LIT;
			goto end;
		case tokens.PTokenType.NUM_LIT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.NUM_LIT;
			goto end;
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.FUNC:
			return self.funcExpr();
		default:
			break;
		}

		tok.print();
		self.error("expected expr, got {tok}");
		return null;

	label end:
		expr.buff = tok.buff;
		expr.len = tok.len;
		
		return expr;
	};
	func exprOrType(self: *Parser) *ast.Expr {
		return self.expr();
	};
	func callExpr(self: *Parser, function: *ast.Expr, statePtr: *ParserState) *ast.Expr {
		self.eat();
		c := (ast.CallExpr){function: function};

		if self.peek().pType == tokens.PTokenType.RPAREN {
			c.args = null;
		} else {
			c.args = self.exprVec();
			self.expectPri(tokens.PTokenType.RPAREN);
		}
		self.eat();
		
		e := self.exprNode(statePtr);
		e.type = ast.ExprType.CALL;
		e.data.callExpr = c;
		return e;
	};
	func newExpr(self: *Parser) *ast.Expr {
		state := self.state();
		newExpr := self.newExprRaw();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.NEW;
		expr.data.newExpr = newExpr;
		return expr;
	};
	func newExprRaw(self: *Parser) ast.NewExpr {
		self.eat();
		newExpr := (ast.NewExpr){};
		
		if self.peek().pType == tokens.PTokenType.LPAREN {
			newExpr.type = null;
			newExpr.val = self.expr();
			return newExpr;
		}
		newExpr.type = self.type();

		if tok := self.peek(); tok.pType == tokens.PTokenType.LPAREN {
			newExpr.val = self.expr();
		}
		return newExpr;
	};
	func awaitExpr(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();
		
		e := self.expr();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.AWAIT;
		expr.data.awaitExpr = (ast.AwaitExpr){expr: e};
		return expr;
	};
	func sizeExpr(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();
		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();

		e := self.expr();

		self.expectPri(tokens.PTokenType.RPAREN);
		self.eat();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.SIZEOF;
		expr.data.sizeExpr = (ast.SizeExpr){expr: e};
		return expr;
	};
	func castExpr(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();
		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();

		type := self.type();

		self.expectPri(tokens.PTokenType.RPAREN);
		self.eat();

		e := self.expr8();
		expr := self.exprNode(&state);
		expr.type = ast.ExprType.UNARY;
		expr.data.castExpr = (ast.CastExpr){expr: e, type: type};
		return expr;
	};
	func arrayInitializer(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();

		elements := self.exprVec();
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.ARRLIT;
		expr.data.arrayLit = (ast.ArrayLit){elements: cast(*void)elements};
		return expr;
	};
	func compLitData(self: *Parser, lit: *ast.CompLit) {
		self.eat();
		tok := self.peek();

		if tok.pType == tokens.PTokenType.RCBRACE {
			lit.fields = null;
			lit.values = null;
			self.eat();
			return;
		}

		e := self.expr();

		if t := self.peek(); e.type != ast.ExprType.IDENT || t.sType != tokens.STokenType.COLON {
			lit.fields = null;
			lit.values = (vec *ast.Expr){};
			lit.values.push(e);

			if t.pType == tokens.PTokenType.RCBRACE {
				self.eat();
				return;
			}
			
			exprs := self.exprVec();
			lit.values.concat(exprs);

			exprs.free();
			goto end;
		}
		delete e;
		
		lit.fields = (vec ast.IdentExpr){};
		lit.values = (vec *ast.Expr){};

		lit.fields.push((ast.IdentExpr){tok});
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		lit.values.push(self.expr());

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();

			lit.fields.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
			self.expectSec(tokens.STokenType.COLON);
			self.eat();
			lit.values.push(self.expr());
		}

	label end:
		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
	};
	func funcExpr(self: *Parser) *ast.Expr {
		state := self.state();
		function := self.funcExprRaw();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.FUNC;
		expr.data.funcExpr = function;
		return expr;
	};
	func funcExprRaw(self: *Parser) ast.FuncExpr {
		self.eat();

		function := (ast.FuncExpr){};
		function.type = new ast.FuncType;
		function.type.args.names = (vec ast.IdentExpr){};
		function.type.args.types = (vec *ast.Type){};

		tok := self.peek();

		switch tok.sType {
		case tokens.STokenType.WORK:
			function.type.type = ast.FuncTypeEnum.WORK;
			self.eat();
			break;
		case tokens.STokenType.ASYNC:
			function.type.type = ast.FuncTypeEnum.ASYNC;
			self.eat();
			break;
		default:
			function.type.type = ast.FuncTypeEnum.ORD;
			break;
		}

		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();
		
		if self.peek().pType != tokens.PTokenType.RPAREN {
			goto body;
		} else {
			goto next;
		}

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();

		label body:
			function.type.args.names.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
			self.expectSec(tokens.STokenType.COLON);
			self.eat();
			function.type.args.types.push(self.type());
		}
		self.expectPri(tokens.PTokenType.RPAREN);

	label next:
		self.eat();

		function.type.returnType = self.type();
		function.body = self.blockRaw();

		return function;
	};
	func decType(self: *Parser) *ast.Type {
		state := self.state();
		
		switch self.peek().sType {
		case tokens.STokenType.STATIC:
			self.eat();

			statc := (ast.StaticType){base: self.type()};
			type := self.typeNode(&state);
			type.type = ast.TypeType.STATIC;
			type.data.statc = statc;
			return type;
		}

		return self.type();
	};
	func type(self: *Parser) *ast.Type { // array
		state := self.state();
		
		if self.peek().pType != tokens.PTokenType.LBRACE {
			return self.type1();
		}
		
		self.eat();
		type: *ast.Type;

		if self.peek().pType != tokens.PTokenType.RBRACE {
			size := new ast.BasicLit{self.expectPri(tokens.PTokenType.NUM_LIT)};
			self.eat();
			self.expectPri(tokens.PTokenType.RBRACE);
			self.eat();

			base := self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.ARRAY;
			type.data.array = (ast.ArrayType){base: base, size: size};
		} else {
			self.eat();
			base := self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.IMPARRAY;
			type.data.impArray = (ast.ImpArrayType){base: base};
		}
		return type;
	};
	func type1(self: *Parser) *ast.Type { // pointer
		state := self.state();

		if self.peek().sType != tokens.STokenType.MUL {
			return self.type2();
		}
		
		self.eat();
		base := self.type();

		type := self.typeNode(&state);
		type.type = ast.TypeType.POINTER;
		type.data.pointer = (ast.PointerType){base: base};
		return type;
	};
	func type2(self: *Parser) *ast.Type { // const, capture, static, promise, vec keywords
		type: *ast.Type;
		state := self.state();
		t: *ast.Type;

		switch self.peek().sType {
		case tokens.STokenType.VEC:
			self.eat();
			t = self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.VECTOR;
			type.data.vector = (ast.VectorType){base: t};
			break;
		case tokens.STokenType.CONST:
			self.eat();
			t = self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.CONST;
			type.data.cnst = (ast.ConstType){base: t};
			break;
		case tokens.STokenType.CAPTURE:
			self.eat();
			t = self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.CAPTURE;
			type.data.cpture = (ast.CaptureType){base: t};
			break;
		case tokens.STokenType.PROMISE:
			self.eat();
			t = self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.PROMISE;
			type.data.promse = (ast.PromiseType){base: t};
			break;
		default:
			return self.type3();
		}
		return type;
	};
	func type3(self: *Parser) *ast.Type { // function, struct, tuple, enum, parenthesis, basic type
		tok := self.peek();
		
		switch tok.sType {
		case tokens.STokenType.FUNC:
			return self.funcType();
		case tokens.STokenType.STRUCT:
			return self.structType();
		case tokens.STokenType.UNION:
			return self.unionType();
		case tokens.STokenType.TUPLE:
			return self.tupleType();
		case tokens.STokenType.ENUM:
			return self.enumType();
		}
		switch tok.pType {
		case tokens.PTokenType.LPAREN:
			self.eat();
			t := self.type();
			self.expectPri(tokens.PTokenType.RPAREN);
			self.eat();
			t.buff--; // for parenthesis
			t.len += 2;
			return t;
		case tokens.PTokenType.IDENT:
			break;
		default:
			break;
		}
		
		state := self.state();
		expr := self.expr();

		type := self.typeNode(&state);
		type.type = ast.TypeType.BASIC;
		type.data.basic = (ast.BasicType){expr};

		return type;
	};
	func funcType(self: *Parser) *ast.Type {
		state := self.state();
		fnc := self.funcTypeRaw();

		type := self.typeNode(&state);
		type.type = ast.TypeType.FUNC;
		type.data.fnc = fnc;
		return type;
	};
	func funcTypeRaw(self: *Parser) ast.FuncType {
		self.eat();

		t := (ast.FuncType){};
		tok := self.peek();

		switch tok.sType {
		case tokens.STokenType.WORK:
			t.type = ast.FuncTypeEnum.WORK;
			self.eat();
			break;
		case tokens.STokenType.ASYNC:
			t.type = ast.FuncTypeEnum.ASYNC;
			self.eat();
			break;
		case tokens.STokenType.NATIVE:
			t.type = ast.FuncTypeEnum.NATIVE;
			self.eat();
			break;
		default:
			t.type = ast.FuncTypeEnum.ORD;
			break;
		}

		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();
		
		t.args.names = null;
		t.args.types = (vec *ast.Type){};
		
		if self.peek().pType != tokens.PTokenType.RPAREN {
			goto body;
		} else {
			goto next;
		}
		
		for self.peek().pType != tokens.PTokenType.RPAREN {
			self.expectSec(tokens.STokenType.COMMA);
			self.eat();

		label body:
			t.args.types.push(self.type());
		}

	label next:
		self.eat();
		
		if tok := self.peek();
			tok.sType != tokens.STokenType.COMMA	 &&
			tok.pType != tokens.PTokenType.SEMICOLON &&
			tok.pType != tokens.PTokenType.RPAREN	&&
			tok.pType != tokens.PTokenType.LCBRACE {
			t.returnType = self.type();
		} else {
			t.returnType = null;
		}
		return t;
	};
	func structTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.structTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;

		return stmt;
	};
	func structTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();

		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();

		type := self.structBody();
		return (ast.Typedef){name: name, type: type};
	};
	func structType(self: *Parser) *ast.Type {
		state := self.state();

		self.eat();
		strct := self.structBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.STRUCT;
		type.data.strct = strct;

		return type;
	};
	func structBody(self: *Parser) *ast.Type {
		state := self.state();
		strct := self.structBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.STRUCT;
		type.data.strct = strct;

		return type;
	};
	func structBodyRaw(self: *Parser) ast.StructType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		strct := (ast.StructType){};
		strct.props = (vec *ast.Stmt){};
		strct.methods = (vec *ast.Stmt){};
		strct.superStructs = (vec *ast.Expr){};

		for tok := self.peek(); tok.pType != tokens.PTokenType.RCBRACE; tok = self.peek() {
			
			if tok.sType == tokens.STokenType.FUNC {
				strct.methods.push(self.funcDec());
			} else if tok.sType == tokens.STokenType.DOTDOT {
				self.eat();
				strct.superStructs.push(self.expr());
			} else {
				strct.props.push(self.dec());
			}
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		}

		self.eat();
		return strct;
	};
	func enumTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.enumTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;

		return stmt;
	};
	func enumTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();

		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();

		type := self.enumBody();
		return (ast.Typedef){name: name, type: type};
	};
	func enumType(self: *Parser) *ast.Type {
		state := self.state();

		self.eat();
		enm := self.enumBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.ENUM;
		type.data.enm = enm;
		
		return type;
	};
	func enumBody(self: *Parser) *ast.Type {
		state := self.state();
		enm := self.enumBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.ENUM;
		type.data.enm = enm;
		
		return type;
	};
	func enumBodyRaw(self: *Parser) ast.EnumType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		enm := (ast.EnumType){idents: (vec ast.IdentExpr){}, values: (vec *ast.Expr){}};
		
	label body:
		enm.idents.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
		self.eat();

		if self.peek().sType == tokens.STokenType.EQ {
			self.eat();
			enm.values.push(self.expr());
		} else {
			enm.values.push(null);
		}
		
		if self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			goto body;
		}

		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();

		return enm;
	};
	func unionTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.unionTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;

		return stmt;
	};
	func unionTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();

		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		
		type := self.unionBody();
		return (ast.Typedef){name: name, type: type};
	};
	func unionType(self: *Parser) *ast.Type {
		state := self.state();

		self.eat();
		unon := self.unionBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.UNION;
		type.data.unon = unon;
		
		return type;
	};
	func unionBody(self: *Parser) *ast.Type {
		state := self.state();
		unon := self.unionBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.UNION;
		type.data.unon = unon;
		
		return type;
	};
	func unionBodyRaw(self: *Parser) ast.UnionType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		unon := (ast.UnionType){decs: (vec ast.Declaration){}};

		for self.peek().pType != tokens.PTokenType.RCBRACE {
			unon.decs.push(self.decNoVal());
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		}

		self.eat();
		return unon;
	};
	func tupleTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.tupleTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;

		return stmt;
	};
	func tupleTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();

		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		
		type := self.tupleBody();
		return (ast.Typedef){name: name, type: type};
	};
	func tupleType(self: *Parser) *ast.Type {
		state := self.state();
		
		self.eat();
		tupl := self.tupleBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.TUPLE;
		type.data.tupl = tupl;
		
		return type;
	};
	func tupleBody(self: *Parser) *ast.Type {
		state := self.state();
		tupl := self.tupleBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.TUPLE;
		type.data.tupl = tupl;
		
		return type;
	};
	func tupleBodyRaw(self: *Parser) ast.TupleType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		tupl := (ast.TupleType){types: self.typeVec()};

		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();

		return tupl;
	};
	func pattern(self: *Parser) *ast.Pattern {
		state := self.state();
		p := self.pattern1();

		for tok := self.peek();
			tok.sType == tokens.STokenType.ANDAND ||
			tok.sType == tokens.STokenType.OROR;
			tok = self.peek() {
			
			self.eat();
			p2 := (ast.BinaryPattern){left: p, right: self.pattern1()};

			p = self.patternNode(&state);
			p.type = ast.PatternType.BINARY;
			p.data.binary = p2;
		}
		return p;
	};
	func pattern1(self: *Parser) *ast.Pattern {
		state := self.state();
		tok := self.peek();
		pattern: *ast.Pattern;

		switch tok.pType {
		case tokens.PTokenType.LPAREN:
			return self.range(&state);
		
		case tokens.PTokenType.LBRACE:
			pattern = self.range(&state);
			pattern.data.range.type += ast.RangeType.LEFT;
			return pattern;

		case tokens.PTokenType.RELAT_OP:
			self.eat();
			p := (ast.UnaryPattern){op: new ast.Operator{tok}, expr: self.expr()};
			
			pattern = self.patternNode(&state);
			pattern.type = ast.PatternType.UNARY;
			pattern.data.unary = p;
			return pattern;
		default:
			break;
		}
		
		switch tok.sType {
		case tokens.STokenType.DOTDOT:
			self.eat();
			p := (ast.Range){left: null, right: self.expr(), type: ast.RangeType.RIGHT};
			
			pattern = self.patternNode(&state);
			pattern.type = ast.PatternType.RANGE;
			pattern.data.range = p;
			return pattern;
		default:
			break;
		}

		e := self.expr();

		if self.peek().sType == tokens.STokenType.DOTDOT {
			p := (ast.Range){left: e, right: null, type: ast.RangeType.LEFT};

			pattern = self.patternNode(&state);
			pattern.type = ast.PatternType.RANGE;
			pattern.data.range = p;
			return pattern;
		}

		p := (ast.ExprPattern){expr: e};

		pattern = self.patternNode(&state);
		pattern.type = ast.PatternType.EXPR;
		pattern.data.expr = p;
		return pattern;
	};
	func range(self: *Parser, statePtr: *ParserState) *ast.Pattern {
		self.eat();
		p := (ast.Range){};

		if self.peek().sType == tokens.STokenType.DOTDOT {
			self.eat();

			p.left = null;
			p.right = self.expr();
			
			if t := self.peek().pType; t == tokens.PTokenType.RPAREN {
				p.type = ast.RangeType.NONE;
			} else if t == tokens.PTokenType.RBRACE {
				p.type - ast.RangeType.RIGHT;
			} else {
				self.error("bruh gib paren or brace");
			}
			self.eat();
			goto end;
		} 
		
		p.left = self.expr();

		self.expectSec(tokens.STokenType.DOTDOT);
		self.eat();

		if t := self.peek().pType; t == tokens.PTokenType.LPAREN || t == tokens.PTokenType.RBRACE {
			self.eat();
			p.type = ast.RangeType.NONE;
			p.right = null;
			goto end;
		}
		p.right = self.expr();

		if t := self.peek().pType; t == tokens.PTokenType.RPAREN {
			p.type = ast.RangeType.NONE;
		} else if t == tokens.PTokenType.RBRACE {
			p.type = ast.RangeType.RIGHT;
		} else {
			self.error("bruh gib paren or brace");
		}
		self.eat();
	
	label end:
		pattern := self.patternNode(statePtr);
		pattern.type = ast.PatternType.RANGE;
		pattern.data.range = p;
		return pattern;
	};
};